// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "Rect.dart" as rect_;

import "Matrix.dart" as matrix_;

import "Point.dart" as point_;

/// from: com.artifex.mupdf.fitz.Quad
class Quad extends jni.JObject {
  @override
  late final jni.JObjType<Quad> $type = type;

  Quad.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"com/artifex/mupdf/fitz/Quad");

  /// The type which includes information such as the signature of this class.
  static const type = $QuadType();
  static final _id_ul_x = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"ul_x",
    r"F",
  );

  /// from: public float ul_x
  double get ul_x => jni.Jni.accessors
      .getField(reference, _id_ul_x, jni.JniCallType.floatType)
      .float;

  /// from: public float ul_x
  set ul_x(double value) =>
      jni.Jni.env.SetFloatField(reference, _id_ul_x, value);

  static final _id_ul_y = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"ul_y",
    r"F",
  );

  /// from: public float ul_y
  double get ul_y => jni.Jni.accessors
      .getField(reference, _id_ul_y, jni.JniCallType.floatType)
      .float;

  /// from: public float ul_y
  set ul_y(double value) =>
      jni.Jni.env.SetFloatField(reference, _id_ul_y, value);

  static final _id_ur_x = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"ur_x",
    r"F",
  );

  /// from: public float ur_x
  double get ur_x => jni.Jni.accessors
      .getField(reference, _id_ur_x, jni.JniCallType.floatType)
      .float;

  /// from: public float ur_x
  set ur_x(double value) =>
      jni.Jni.env.SetFloatField(reference, _id_ur_x, value);

  static final _id_ur_y = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"ur_y",
    r"F",
  );

  /// from: public float ur_y
  double get ur_y => jni.Jni.accessors
      .getField(reference, _id_ur_y, jni.JniCallType.floatType)
      .float;

  /// from: public float ur_y
  set ur_y(double value) =>
      jni.Jni.env.SetFloatField(reference, _id_ur_y, value);

  static final _id_ll_x = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"ll_x",
    r"F",
  );

  /// from: public float ll_x
  double get ll_x => jni.Jni.accessors
      .getField(reference, _id_ll_x, jni.JniCallType.floatType)
      .float;

  /// from: public float ll_x
  set ll_x(double value) =>
      jni.Jni.env.SetFloatField(reference, _id_ll_x, value);

  static final _id_ll_y = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"ll_y",
    r"F",
  );

  /// from: public float ll_y
  double get ll_y => jni.Jni.accessors
      .getField(reference, _id_ll_y, jni.JniCallType.floatType)
      .float;

  /// from: public float ll_y
  set ll_y(double value) =>
      jni.Jni.env.SetFloatField(reference, _id_ll_y, value);

  static final _id_lr_x = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"lr_x",
    r"F",
  );

  /// from: public float lr_x
  double get lr_x => jni.Jni.accessors
      .getField(reference, _id_lr_x, jni.JniCallType.floatType)
      .float;

  /// from: public float lr_x
  set lr_x(double value) =>
      jni.Jni.env.SetFloatField(reference, _id_lr_x, value);

  static final _id_lr_y = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r"lr_y",
    r"F",
  );

  /// from: public float lr_y
  double get lr_y => jni.Jni.accessors
      .getField(reference, _id_lr_y, jni.JniCallType.floatType)
      .float;

  /// from: public float lr_y
  set lr_y(double value) =>
      jni.Jni.env.SetFloatField(reference, _id_lr_y, value);

  static final _id_ctor = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"<init>", r"(FFFFFFFF)V");

  /// from: public void <init>(float f, float f1, float f2, float f3, float f4, float f5, float f6, float f7)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Quad(
    double f,
    double f1,
    double f2,
    double f3,
    double f4,
    double f5,
    double f6,
    double f7,
  ) {
    return Quad.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_ctor, [
      jni.JValueFloat(f),
      jni.JValueFloat(f1),
      jni.JValueFloat(f2),
      jni.JValueFloat(f3),
      jni.JValueFloat(f4),
      jni.JValueFloat(f5),
      jni.JValueFloat(f6),
      jni.JValueFloat(f7)
    ]).object);
  }

  static final _id_ctor1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"<init>", r"(Lcom/artifex/mupdf/fitz/Rect;)V");

  /// from: public void <init>(com.artifex.mupdf.fitz.Rect rect)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory Quad.ctor1(
    rect_.Rect rect,
  ) {
    return Quad.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_ctor1, [rect.reference]).object);
  }

  static final _id_toRect = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"toRect", r"()Lcom/artifex/mupdf/fitz/Rect;");

  /// from: public com.artifex.mupdf.fitz.Rect toRect()
  /// The returned object must be deleted after use, by calling the `delete` method.
  rect_.Rect toRect() {
    return const rect_.$RectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toRect, jni.JniCallType.objectType, []).object);
  }

  static final _id_transformed = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"transformed",
      r"(Lcom/artifex/mupdf/fitz/Matrix;)Lcom/artifex/mupdf/fitz/Quad;");

  /// from: public com.artifex.mupdf.fitz.Quad transformed(com.artifex.mupdf.fitz.Matrix matrix)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Quad transformed(
    matrix_.Matrix matrix,
  ) {
    return const $QuadType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_transformed,
        jni.JniCallType.objectType,
        [matrix.reference]).object);
  }

  static final _id_transform = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"transform",
      r"(Lcom/artifex/mupdf/fitz/Matrix;)Lcom/artifex/mupdf/fitz/Quad;");

  /// from: public com.artifex.mupdf.fitz.Quad transform(com.artifex.mupdf.fitz.Matrix matrix)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Quad transform(
    matrix_.Matrix matrix,
  ) {
    return const $QuadType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_transform,
        jni.JniCallType.objectType,
        [matrix.reference]).object);
  }

  static final _id_triangleContainsPoint = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"triangleContainsPoint", r"(FFFFFFFF)Z");

  /// from: protected boolean triangleContainsPoint(float f, float f1, float f2, float f3, float f4, float f5, float f6, float f7)
  bool triangleContainsPoint(
    double f,
    double f1,
    double f2,
    double f3,
    double f4,
    double f5,
    double f6,
    double f7,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_triangleContainsPoint, jni.JniCallType.booleanType, [
      jni.JValueFloat(f),
      jni.JValueFloat(f1),
      jni.JValueFloat(f2),
      jni.JValueFloat(f3),
      jni.JValueFloat(f4),
      jni.JValueFloat(f5),
      jni.JValueFloat(f6),
      jni.JValueFloat(f7)
    ]).boolean;
  }

  static final _id_contains =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"contains", r"(FF)Z");

  /// from: public boolean contains(float f, float f1)
  bool contains(
    double f,
    double f1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_contains,
        jni.JniCallType.booleanType,
        [jni.JValueFloat(f), jni.JValueFloat(f1)]).boolean;
  }

  static final _id_contains1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"contains", r"(Lcom/artifex/mupdf/fitz/Point;)Z");

  /// from: public boolean contains(com.artifex.mupdf.fitz.Point point)
  bool contains1(
    point_.Point point,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_contains1,
        jni.JniCallType.booleanType, [point.reference]).boolean;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }
}

class $QuadType extends jni.JObjType<Quad> {
  const $QuadType();

  @override
  String get signature => r"Lcom/artifex/mupdf/fitz/Quad;";

  @override
  Quad fromRef(jni.JObjectPtr ref) => Quad.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($QuadType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($QuadType) && other is $QuadType;
  }
}
